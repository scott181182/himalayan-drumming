### This file was generated by Nexus Schema
### Do not make changes to this file directly


type FileEntry {
  children: [FileEntry!]
  id: ID!
  metadata: FileMetadata
  name: String!
  parent: FileEntry
  parentId: ID
  people: [Person!]!
  tags: [String!]!
  type: String!
  url: String
}

type FileMetadata {
  file: FileEntry!
  fileId: ID!
  location: LatLng
  locationId: ID
}

input FileMetadataCreateLocationInput {
  connect: IdWhereUniqueInput
  create: LatLngCreateInput
}

input FileMetadataUpdateInput {
  location: FileMetadataCreateLocationInput
}

input IdWhereUniqueInput {
  id: ID!
}

type LatLng {
  id: ID!
  latitude: Float!
  longitude: Float!
}

input LatLngCreateInput {
  latitude: Float!
  longitude: Float!
}

type Mutation {
  createPerson(data: PersonCreateInput!): Person!
  createVillage(data: VillageCreateInput!): Village!

  """
  Perform a full scan of OneDrive and other file sources. Creates, updates, and deletes entries as necessary.
  """
  fullscan: FileEntry
  tagFile(fileId: ID!, tag: String!): FileEntry!
  untagFile(fileId: ID!, tag: String!): FileEntry!
  updateMetadata(data: FileMetadataUpdateInput!, fileId: ID!): FileMetadata!
  updatePerson(data: PersonUpdateInput!, id: ID!): Person!
}

enum OrderDirection {
  asc
  desc
}

type Person {
  children: [Person!]!
  files: [FileEntry!]!
  id: ID!
  name: String!
  parent: Person
  parentId: String
  villages: [PersonInVillage!]!
}

input PersonCreateInput {
  name: String!
  parentId: String
  villages: VillageForPersonRelationCreateInput
}

input PersonIdVillageIdInput {
  personId: ID!
  villageId: ID!
}

type PersonInVillage {
  description: String
  person: Person!
  personId: ID!
  village: Village!
  villageId: ID!
}

input PersonInVillageCreateInput {
  description: String
  villageId: ID!
}

input PersonInVillageUniqueWhereInput {
  personId_villageId: PersonIdVillageIdInput!
}

input PersonOrderByInput {
  name: OrderDirection
}

input PersonUpdateInput {
  name: String
  parentId: String
  villages: VillageForPersonRelationUpdateInput
}

input PersonWhereInput {
  id: ID
  name: String
  parentId: String
}

type Query {
  fileEntries: [FileEntry!]!
  fileEntry(id: String!): FileEntry
  people(orderBy: PersonOrderByInput, skip: Int! = 0, take: Int! = 20, where: PersonWhereInput): [Person!]!
  person(id: ID!): Person
  rootFileEntry: FileEntry!
  tags: [String!]!
  village(id: ID!): Village
  villages: [Village!]!
}

type Village {
  id: ID!
  location: LatLng!
  locationId: String!
  name: String!
  people: [PersonInVillage!]!
}

input VillageCreateInput {
  location: VillageCreateLocationInput!
  name: String!
}

input VillageCreateLocationInput {
  connect: IdWhereUniqueInput
  create: LatLngCreateInput
}

input VillageForPersonRelationCreateInput {
  connect: PersonInVillageUniqueWhereInput
  create: PersonInVillageCreateInput
}

input VillageForPersonRelationUpdateInput {
  connect: PersonInVillageUniqueWhereInput
  create: PersonInVillageCreateInput
  delete: PersonInVillageUniqueWhereInput
}