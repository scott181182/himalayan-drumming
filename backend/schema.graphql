### This file was generated by Nexus Schema
### Do not make changes to this file directly


input CreateFileReferenceInput {
  name: String!
  parentId: ID!
  url: String!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

input DateNullableFilterInput {
  equals: Date
  gt: Date
  gte: Date
  in: [Date!]
  lt: Date
  lte: Date
  notIn: [Date!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input FileCreateLocationInput {
  connect: IdWhereUniqueInput
  create: LatLngCreateInput
}

type FileEntry {
  associatedFiles: [FileEntry!]!
  children: [FileEntry!]
  id: ID!
  location: LatLng
  locationId: ID
  name: String!
  parent: FileEntry
  parentId: ID
  people: [PersonOnFile!]!
  tags: [String!]!
  type: String!
  url: String
}

input FileEntryUpdateInput {
  location: FileCreateLocationInput
  notes: String
  people: PersonOnFileFileRelationUpdateInput
  timestamp: DateTime
}

input FileEntryWhereInput {
  id: IdNullableFilterInput
  name: StringNullableFilterInput
  parentId: IdNullableFilterInput
  tags: StringNullableArrayFilterInput
  type: StringNullableFilterInput
  url: StringNullableFilterInput
}

input IdNullableFilterInput {
  equals: ID
  in: [ID!]
  not: NestedIdNullableFilterInput
  notIn: [ID!]
}

input IdWhereUniqueInput {
  id: ID!
}

type LatLng {
  id: ID!
  latitude: Float!
  longitude: Float!
}

input LatLngCreateInput {
  latitude: Float!
  longitude: Float!
}

type Mutation {
  associateFiles(file1Id: ID!, file2Id: ID!): [FileEntry!]
  createDirectory(name: String!, parentId: ID!): FileEntry
  createFileReference(data: CreateFileReferenceInput!): FileEntry
  createPerson(data: PersonCreateInput!): Person!
  createVillage(data: VillageCreateInput!): Village!
  disassociateFiles(file1Id: ID!, file2Id: ID!): [FileEntry!]

  """
  Perform a full scan of OneDrive and other file sources. Creates, updates, and deletes entries as necessary.
  """
  fullscan: FileEntry
  removePersonFromFile(fileId: ID!, personId: ID!): Boolean!
  removePersonFromVillage(personId: ID!, villageId: ID!): Boolean!
  tagFile(fileId: ID!, tag: String!): FileEntry!
  untagFile(fileId: ID!, tag: String!): FileEntry!
  updateFile(data: FileEntryUpdateInput!, fileId: ID!): FileEntry
  updatePerson(data: PersonUpdateInput!, id: ID!): Person!
  updateVillage(data: VillageUpdateInput!, id: ID!): Village!
}

input NestedIdNullableFilterInput {
  equals: ID
  in: [ID!]
  not: NestedIdNullableFilterInput
  notIn: [ID!]
}

input NestedStringNullableFilterInput {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilterInput
  notIn: [String!]
  startsWith: String
}

enum OrderDirection {
  asc
  desc
}

type Person {
  avatarUrl: String
  birthdate: Date
  caste: String
  children: [Person!]!
  education: String
  files: [PersonOnFile!]!
  gender: String
  id: ID!
  name: String!
  notes: String
  parent: Person
  parentId: String
  villages: [PersonInVillage!]!
}

input PersonCreateInput {
  birthdate: Date
  caste: String
  education: String
  files: PersonOnFilePersonRelationCreateInput
  gender: String
  name: String!
  notes: String
  parentId: String
  villages: PersonInVillagePersonRelationCreateInput
}

input PersonIdFileIdInput {
  fileId: ID!
  personId: ID!
}

input PersonIdVillageIdInput {
  personId: ID!
  villageId: ID!
}

type PersonInVillage {
  description: String
  person: Person!
  personId: ID!
  village: Village!
  villageId: ID!
}

input PersonInVillagePersonCreateInput {
  description: String
  villageId: ID!
}

input PersonInVillagePersonRelationCreateInput {
  connect: PersonInVillageUniqueWhereInput
  create: PersonInVillagePersonCreateInput
}

input PersonInVillagePersonRelationUpdateInput {
  connect: PersonInVillageUniqueWhereInput
  create: PersonInVillagePersonCreateInput
  delete: PersonInVillageUniqueWhereInput
}

input PersonInVillageUniqueWhereInput {
  personId_villageId: PersonIdVillageIdInput!
}

input PersonInVillageVillageCreateInput {
  description: String
  personId: ID!
}

input PersonInVillageVillageRelationCreateInput {
  connect: PersonInVillageUniqueWhereInput
  create: PersonInVillageVillageCreateInput
}

input PersonInVillageVillageRelationUpdateInput {
  connect: PersonInVillageUniqueWhereInput
  create: PersonInVillageVillageCreateInput
  delete: PersonInVillageUniqueWhereInput
}

input PersonInVillageWhereInput {
  AND: [PersonInVillageWhereInput!]
  NOT: [PersonInVillageWhereInput!]
  OR: [PersonInVillageWhereInput!]
  description: StringNullableFilterInput
  person: PersonWhereInput
  personId: IdNullableFilterInput
  village: VillageWhereInput
  villageId: IdNullableFilterInput
}

input PersonInVillageWhereManyInput {
  every: PersonInVillageWhereInput
  none: PersonInVillageWhereInput
  some: PersonInVillageWhereInput
}

type PersonOnFile {
  file: FileEntry!
  fileId: ID!
  instrument: String
  notes: String
  person: Person!
  personId: ID!
}

input PersonOnFileFileCreateInput {
  instrument: String
  notes: String
  personId: ID!
}

input PersonOnFileFileRelationCreateInput {
  connect: PersonOnFileUniqueWhereInput
  create: PersonOnFileFileCreateInput
}

input PersonOnFileFileRelationUpdateInput {
  connect: PersonOnFileUniqueWhereInput
  create: PersonOnFileFileCreateInput
  delete: PersonOnFileUniqueWhereInput
}

input PersonOnFilePersonCreateInput {
  fileId: ID!
  instrument: String
  notes: String
}

input PersonOnFilePersonRelationCreateInput {
  connect: PersonOnFileUniqueWhereInput
  create: PersonOnFilePersonCreateInput
}

input PersonOnFilePersonRelationUpdateInput {
  connect: PersonOnFileUniqueWhereInput
  create: PersonOnFilePersonCreateInput
  delete: PersonOnFileUniqueWhereInput
}

input PersonOnFileUniqueWhereInput {
  personId_fileId: PersonIdFileIdInput!
}

input PersonOnFileWhereInput {
  AND: [PersonOnFileWhereInput!]
  NOT: [PersonOnFileWhereInput!]
  OR: [PersonOnFileWhereInput!]
  file: FileEntryWhereInput
  fileId: IdNullableFilterInput
  instrument: StringNullableFilterInput
  notes: StringNullableFilterInput
  person: PersonWhereInput
  personId: IdNullableFilterInput
}

input PersonOnFileWhereManyInput {
  every: PersonOnFileWhereInput
  none: PersonOnFileWhereInput
  some: PersonOnFileWhereInput
}

input PersonOrderByInput {
  name: OrderDirection
}

input PersonUpdateInput {
  birthdate: Date
  caste: String
  education: String
  files: PersonOnFilePersonRelationUpdateInput
  gender: String
  name: String
  notes: String
  parentId: String
  villages: PersonInVillagePersonRelationUpdateInput
}

input PersonWhereInput {
  AND: [PersonWhereInput!]
  NOT: [PersonWhereInput!]
  OR: [PersonWhereInput!]
  birthdate: DateNullableFilterInput
  caste: StringNullableFilterInput
  children: PersonWhereManyInput
  education: StringNullableFilterInput
  gender: StringNullableFilterInput
  id: IdNullableFilterInput
  name: StringNullableFilterInput
  notes: StringNullableFilterInput
  parent: PersonWhereInput
  parentId: IdNullableFilterInput
  villages: PersonInVillageWhereManyInput
}

input PersonWhereManyInput {
  every: PersonWhereInput
  none: PersonWhereInput
  some: PersonWhereInput
}

type Query {
  castes: [String!]!
  fileEntries(skip: Int! = 0, take: Int, where: FileEntryWhereInput): [FileEntry!]!
  fileEntry(id: ID!): FileEntry
  genders: [String!]!
  people(orderBy: PersonOrderByInput, skip: Int! = 0, take: Int! = 20, where: PersonWhereInput): [Person!]!
  person(id: ID!): Person
  rootFileEntry: FileEntry!
  tags: [String!]!
  village(id: ID!): Village
  villages(where: VillageWhereInput): [Village!]!
}

input StringNullableArrayFilterInput {
  every: StringNullableFilterInput
  none: StringNullableFilterInput
  some: StringNullableFilterInput
}

input StringNullableFilterInput {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilterInput
  notIn: [String!]
  startsWith: String
}

enum StringQueryModeEnum {
  default
  insensitive
}

type Village {
  divinities: String
  id: ID!
  location: LatLng!
  locationId: String!
  name: String!
  notes: String
  people: [PersonInVillage!]!
  rituals: String
  temples: String
}

input VillageCreateInput {
  divinities: String
  location: VillageCreateLocationInput!
  name: String!
  notes: String
  people: PersonInVillageVillageRelationCreateInput
  rituals: String
  temples: String
}

input VillageCreateLocationInput {
  connect: IdWhereUniqueInput
  create: LatLngCreateInput
}

input VillageUpdateInput {
  divinities: String
  location: VillageCreateLocationInput
  name: String
  notes: String
  people: PersonInVillageVillageRelationUpdateInput
  rituals: String
  temples: String
}

input VillageWhereInput {
  AND: [VillageWhereInput!]
  NOT: [VillageWhereInput!]
  OR: [VillageWhereInput!]
  divinities: StringNullableFilterInput
  id: IdNullableFilterInput
  name: StringNullableFilterInput
  notes: StringNullableFilterInput
  people: PersonInVillageWhereManyInput
  rituals: StringNullableFilterInput
  temples: StringNullableFilterInput
}