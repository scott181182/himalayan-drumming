### This file was generated by Nexus Schema
### Do not make changes to this file directly


input CreateFileReferenceInput {
  name: String!
  parentId: ID!
  url: String!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

input DateNullableFilterInput {
  equals: Date
  gt: Date
  gte: Date
  in: [Date!]
  lt: Date
  lte: Date
  notIn: [Date!]
}

type FileEntry {
  associatedFiles: [FileEntry!]!
  children: [FileEntry!]
  id: ID!
  metadata: FileMetadata
  name: String!
  parent: FileEntry
  parentId: ID
  people: [Person!]!
  tags: [String!]!
  type: String!
  url: String
}

input FileEntryWhereInput {
  id: IdNullableFilterInput
  name: StringNullableFilterInput
  parentId: IdNullableFilterInput
  tags: StringNullableArrayFilterInput
  type: StringNullableFilterInput
  url: StringNullableFilterInput
}

type FileMetadata {
  file: FileEntry!
  fileId: ID!
  location: LatLng
  locationId: ID
}

input FileMetadataCreateLocationInput {
  connect: IdWhereUniqueInput
  create: LatLngCreateInput
}

input FileMetadataUpdateInput {
  location: FileMetadataCreateLocationInput
}

input FilesForPersonCreateInput {
  connect: [IdWhereUniqueInput!]
}

input FilesForPersonUpdateInput {
  connect: [IdWhereUniqueInput!]
  disconnect: [IdWhereUniqueInput!]
}

input IdNullableFilterInput {
  equals: String
  in: [String!]
  not: NestedIdNullableFilterInput
  notIn: [String!]
}

input IdWhereUniqueInput {
  id: ID!
}

type LatLng {
  id: ID!
  latitude: Float!
  longitude: Float!
}

input LatLngCreateInput {
  latitude: Float!
  longitude: Float!
}

type Mutation {
  associateFiles(file1Id: ID!, file2Id: ID!): [FileEntry!]
  createDirectory(name: String!, parentId: ID!): FileEntry
  createFileReference(data: CreateFileReferenceInput!): FileEntry
  createPerson(data: PersonCreateInput!): Person!
  createVillage(data: VillageCreateInput!): Village!
  disassociateFiles(file1Id: ID!, file2Id: ID!): [FileEntry!]

  """
  Perform a full scan of OneDrive and other file sources. Creates, updates, and deletes entries as necessary.
  """
  fullscan: FileEntry
  tagFile(fileId: ID!, tag: String!): FileEntry!
  untagFile(fileId: ID!, tag: String!): FileEntry!
  updateMetadata(data: FileMetadataUpdateInput!, fileId: ID!): FileEntry!
  updatePerson(data: PersonUpdateInput!, id: ID!): Person!
}

input NestedIdNullableFilterInput {
  equals: String
  in: [String!]
  not: NestedIdNullableFilterInput
  notIn: [String!]
}

input NestedStringNullableFilterInput {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilterInput
  notIn: [String!]
  startsWith: String
}

enum OrderDirection {
  asc
  desc
}

type Person {
  avatarUrl: String
  birthdate: Date
  caste: String
  children: [Person!]!
  education: String
  files: [FileEntry!]!
  gender: String
  id: ID!
  name: String!
  notes: String
  parent: Person
  parentId: String
  villages: [PersonInVillage!]!
}

input PersonCreateInput {
  birthdate: Date
  caste: String
  education: String
  files: FilesForPersonCreateInput
  gender: String
  name: String!
  notes: String
  parentId: String
  villages: PersonInVillageRelationCreateInput
}

input PersonIdVillageIdInput {
  personId: ID!
  villageId: ID!
}

type PersonInVillage {
  description: String
  person: Person!
  personId: ID!
  village: Village!
  villageId: ID!
}

input PersonInVillageCreateInput {
  description: String
  villageId: ID!
}

input PersonInVillageRelationCreateInput {
  connect: PersonInVillageUniqueWhereInput
  create: PersonInVillageCreateInput
}

input PersonInVillageRelationUpdateInput {
  connect: PersonInVillageUniqueWhereInput
  create: PersonInVillageCreateInput
  delete: PersonInVillageUniqueWhereInput
}

input PersonInVillageUniqueWhereInput {
  personId_villageId: PersonIdVillageIdInput!
}

input PersonInVillageWhereInput {
  AND: [PersonInVillageWhereInput!]
  NOT: [PersonInVillageWhereInput!]
  OR: [PersonInVillageWhereInput!]
  description: StringNullableFilterInput
  person: PersonWhereInput
  personId: IdNullableFilterInput
  village: VillageWhereInput
  villageId: IdNullableFilterInput
}

input PersonInVillageWhereManyInput {
  every: PersonInVillageWhereInput
  none: PersonInVillageWhereInput
  some: PersonInVillageWhereInput
}

input PersonOrderByInput {
  name: OrderDirection
}

input PersonUpdateInput {
  birthdate: Date
  caste: String
  education: String
  files: FilesForPersonUpdateInput
  gender: String
  name: String
  notes: String
  parentId: String
  villages: PersonInVillageRelationUpdateInput
}

input PersonWhereInput {
  AND: [PersonWhereInput!]
  NOT: [PersonWhereInput!]
  OR: [PersonWhereInput!]
  birthdate: DateNullableFilterInput
  caste: StringNullableFilterInput
  children: PersonWhereManyInput
  education: StringNullableFilterInput
  gender: StringNullableFilterInput
  id: IdNullableFilterInput
  name: StringNullableFilterInput
  notes: StringNullableFilterInput
  parent: PersonWhereInput
  parentId: IdNullableFilterInput
  villages: PersonInVillageWhereManyInput
}

input PersonWhereManyInput {
  every: PersonWhereInput
  none: PersonWhereInput
  some: PersonWhereInput
}

type Query {
  castes: [String!]!
  fileEntries(skip: Int! = 0, take: Int, where: FileEntryWhereInput): [FileEntry!]!
  fileEntry(id: ID!): FileEntry
  genders: [String!]!
  people(orderBy: PersonOrderByInput, skip: Int! = 0, take: Int! = 20, where: PersonWhereInput): [Person!]!
  person(id: ID!): Person
  rootFileEntry: FileEntry!
  tags: [String!]!
  village(id: ID!): Village
  villages: [Village!]!
}

input StringNullableArrayFilterInput {
  every: StringNullableFilterInput
  none: StringNullableFilterInput
  some: StringNullableFilterInput
}

input StringNullableFilterInput {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilterInput
  notIn: [String!]
  startsWith: String
}

enum StringQueryModeEnum {
  default
  insensitive
}

type Village {
  id: ID!
  location: LatLng!
  locationId: String!
  name: String!
  people: [PersonInVillage!]!
}

input VillageCreateInput {
  location: VillageCreateLocationInput!
  name: String!
}

input VillageCreateLocationInput {
  connect: IdWhereUniqueInput
  create: LatLngCreateInput
}

input VillageWhereInput {
  id: IdNullableFilterInput
  name: StringNullableFilterInput
}